{"ast":null,"code":"import _slicedToArray from \"/Users/nikita/Projects/insa/web-socket-messenger/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/nikita/Projects/insa/web-socket-messenger/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nikita/Projects/insa/web-socket-messenger/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BYTE } from './byte';\nimport { FrameImpl } from './frame-impl';\nimport { Parser } from './parser';\nimport { StompSocketState } from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport var StompHandler =\n/*#__PURE__*/\nfunction () {\n  function StompHandler(_client, _webSocket) {\n    var _this = this;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, StompHandler);\n\n    this._client = _client;\n    this._webSocket = _webSocket;\n    this._serverFrameHandlers = {\n      // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n      CONNECTED: function CONNECTED(frame) {\n        _this.debug(\"connected to server \".concat(frame.headers.server));\n\n        _this._connected = true;\n        _this._connectedVersion = frame.headers.version; // STOMP version 1.2 needs header values to be escaped\n\n        if (_this._connectedVersion === Versions.V1_2) {\n          _this._escapeHeaderValues = true;\n        }\n\n        _this._setupHeartbeat(frame.headers);\n\n        _this.onConnect(frame);\n      },\n      // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n      MESSAGE: function MESSAGE(frame) {\n        // the callback is registered when the client calls\n        // `subscribe()`.\n        // If there is no registered subscription for the received message,\n        // the default `onUnhandledMessage` callback is used that the client can set.\n        // This is useful for subscriptions that are automatically created\n        // on the browser side (e.g. [RabbitMQ's temporary\n        // queues](http://www.rabbitmq.com/stomp.html)).\n        var subscription = frame.headers.subscription;\n        var onReceive = _this._subscriptions[subscription] || _this.onUnhandledMessage; // bless the frame to be a Message\n\n        var message = frame;\n        var client = _this;\n        var messageId = _this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id']; // add `ack()` and `nack()` methods directly to the returned frame\n        // so that a simple call to `message.ack()` can acknowledge the message.\n\n        message.ack = function () {\n          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.ack(messageId, subscription, headers);\n        };\n\n        message.nack = function () {\n          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.nack(messageId, subscription, headers);\n        };\n\n        onReceive(message);\n      },\n      // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n      RECEIPT: function RECEIPT(frame) {\n        var callback = _this._receiptWatchers[frame.headers['receipt-id']];\n\n        if (callback) {\n          callback(frame); // Server will acknowledge only once, remove the callback\n\n          delete _this._receiptWatchers[frame.headers['receipt-id']];\n        } else {\n          _this.onUnhandledReceipt(frame);\n        }\n      },\n      // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n      ERROR: function ERROR(frame) {\n        _this.onStompError(frame);\n      }\n    }; // used to index subscribers\n\n    this._counter = 0; // subscription callbacks indexed by subscriber's ID\n\n    this._subscriptions = {}; // receipt-watchers indexed by receipts-ids\n\n    this._receiptWatchers = {};\n    this._partialData = '';\n    this._escapeHeaderValues = false;\n    this._lastServerActivityTS = Date.now();\n    this.configure(config);\n  }\n\n  _createClass(StompHandler, [{\n    key: \"configure\",\n    value: function configure(conf) {\n      // bulk assign all properties to this\n      Object.assign(this, conf);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      var parser = new Parser( // On Frame\n      function (rawFrame) {\n        var frame = FrameImpl.fromRawFrame(rawFrame, _this2._escapeHeaderValues); // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n\n        if (!_this2.logRawCommunication) {\n          _this2.debug(\"<<< \".concat(frame));\n        }\n\n        var serverFrameHandler = _this2._serverFrameHandlers[frame.command] || _this2.onUnhandledFrame;\n        serverFrameHandler(frame);\n      }, // On Incoming Ping\n      function () {\n        _this2.debug('<<< PONG');\n      });\n\n      this._webSocket.onmessage = function (evt) {\n        _this2.debug('Received data');\n\n        _this2._lastServerActivityTS = Date.now();\n\n        if (_this2.logRawCommunication) {\n          var rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n\n          _this2.debug(\"<<< \".concat(rawChunkAsString));\n        }\n\n        parser.parseChunk(evt.data, _this2.appendMissingNULLonIncoming);\n      };\n\n      this._onclose = function (closeEvent) {\n        _this2.debug(\"Connection closed to \".concat(_this2._client.brokerURL));\n\n        _this2._cleanUp();\n\n        _this2.onWebSocketClose(closeEvent);\n      };\n\n      this._webSocket.onclose = this._onclose;\n\n      this._webSocket.onerror = function (errorEvent) {\n        _this2.onWebSocketError(errorEvent);\n      };\n\n      this._webSocket.onopen = function () {\n        // Clone before updating\n        var connectHeaders = Object.assign({}, _this2.connectHeaders);\n\n        _this2.debug('Web Socket Opened...');\n\n        connectHeaders['accept-version'] = _this2.stompVersions.supportedVersions();\n        connectHeaders['heart-beat'] = [_this2.heartbeatOutgoing, _this2.heartbeatIncoming].join(',');\n\n        _this2._transmit({\n          command: 'CONNECT',\n          headers: connectHeaders\n        });\n      };\n    }\n  }, {\n    key: \"_setupHeartbeat\",\n    value: function _setupHeartbeat(headers) {\n      var _this3 = this;\n\n      if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n        return;\n      } // It is valid for the server to not send this header\n      // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n\n\n      if (!headers['heart-beat']) {\n        return;\n      } // heart-beat header received from the server looks like:\n      //\n      //     heart-beat: sx, sy\n\n\n      var _headers$heartBeat$s = headers['heart-beat'].split(',').map(function (v) {\n        return parseInt(v, 10);\n      }),\n          _headers$heartBeat$s2 = _slicedToArray(_headers$heartBeat$s, 2),\n          serverOutgoing = _headers$heartBeat$s2[0],\n          serverIncoming = _headers$heartBeat$s2[1];\n\n      if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n        var ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n        this.debug(\"send PING every \".concat(ttl, \"ms\"));\n        this._pinger = setInterval(function () {\n          if (_this3._webSocket.readyState === StompSocketState.OPEN) {\n            _this3._webSocket.send(BYTE.LF);\n\n            _this3.debug('>>> PING');\n          }\n        }, ttl);\n      }\n\n      if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n        var _ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n\n        this.debug(\"check PONG every \".concat(_ttl, \"ms\"));\n        this._ponger = setInterval(function () {\n          var delta = Date.now() - _this3._lastServerActivityTS; // We wait twice the TTL to be flexible on window's setInterval calls\n\n\n          if (delta > _ttl * 2) {\n            _this3.debug(\"did not receive server activity for the last \".concat(delta, \"ms\"));\n\n            _this3._closeOrDiscardWebsocket();\n          }\n        }, _ttl);\n      }\n    }\n  }, {\n    key: \"_closeOrDiscardWebsocket\",\n    value: function _closeOrDiscardWebsocket() {\n      if (this.discardWebsocketOnCommFailure) {\n        this.debug('Discarding websocket, the underlying socket may linger for a while');\n\n        this._discardWebsocket();\n      } else {\n        this.debug('Issuing close on the websocket');\n\n        this._closeWebsocket();\n      }\n    }\n  }, {\n    key: \"forceDisconnect\",\n    value: function forceDisconnect() {\n      if (this._webSocket) {\n        if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n          this._closeOrDiscardWebsocket();\n        }\n      }\n    }\n  }, {\n    key: \"_closeWebsocket\",\n    value: function _closeWebsocket() {\n      this._webSocket.onmessage = function () {}; // ignore messages\n\n\n      this._webSocket.close();\n    }\n  }, {\n    key: \"_discardWebsocket\",\n    value: function _discardWebsocket() {\n      var _this4 = this;\n\n      if (!this._webSocket.terminate) {\n        augmentWebsocket(this._webSocket, function (msg) {\n          return _this4.debug(msg);\n        });\n      }\n\n      this._webSocket.terminate();\n    }\n  }, {\n    key: \"_transmit\",\n    value: function _transmit(params) {\n      var command = params.command,\n          headers = params.headers,\n          body = params.body,\n          binaryBody = params.binaryBody,\n          skipContentLengthHeader = params.skipContentLengthHeader;\n      var frame = new FrameImpl({\n        command: command,\n        headers: headers,\n        body: body,\n        binaryBody: binaryBody,\n        escapeHeaderValues: this._escapeHeaderValues,\n        skipContentLengthHeader: skipContentLengthHeader\n      });\n      var rawChunk = frame.serialize();\n\n      if (this.logRawCommunication) {\n        this.debug(\">>> \".concat(rawChunk));\n      } else {\n        this.debug(\">>> \".concat(frame));\n      }\n\n      if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n        rawChunk = new TextEncoder().encode(rawChunk);\n      }\n\n      if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n        this._webSocket.send(rawChunk);\n      } else {\n        var out = rawChunk;\n\n        while (out.length > 0) {\n          var chunk = out.substring(0, this.maxWebSocketChunkSize);\n          out = out.substring(this.maxWebSocketChunkSize);\n\n          this._webSocket.send(chunk);\n\n          this.debug(\"chunk sent = \".concat(chunk.length, \", remaining = \").concat(out.length));\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this5 = this;\n\n      if (this.connected) {\n        try {\n          // clone before updating\n          var disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n\n          if (!disconnectHeaders.receipt) {\n            disconnectHeaders.receipt = \"close-\".concat(this._counter++);\n          }\n\n          this.watchForReceipt(disconnectHeaders.receipt, function (frame) {\n            _this5._closeWebsocket();\n\n            _this5._cleanUp();\n\n            _this5.onDisconnect(frame);\n          });\n\n          this._transmit({\n            command: 'DISCONNECT',\n            headers: disconnectHeaders\n          });\n        } catch (error) {\n          this.debug(\"Ignoring error during disconnect \".concat(error));\n        }\n      } else {\n        if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n          this._closeWebsocket();\n        }\n      }\n    }\n  }, {\n    key: \"_cleanUp\",\n    value: function _cleanUp() {\n      this._connected = false;\n\n      if (this._pinger) {\n        clearInterval(this._pinger);\n      }\n\n      if (this._ponger) {\n        clearInterval(this._ponger);\n      }\n    }\n  }, {\n    key: \"publish\",\n    value: function publish(params) {\n      var destination = params.destination,\n          headers = params.headers,\n          body = params.body,\n          binaryBody = params.binaryBody,\n          skipContentLengthHeader = params.skipContentLengthHeader;\n      var hdrs = Object.assign({\n        destination: destination\n      }, headers);\n\n      this._transmit({\n        command: 'SEND',\n        headers: hdrs,\n        body: body,\n        binaryBody: binaryBody,\n        skipContentLengthHeader: skipContentLengthHeader\n      });\n    }\n  }, {\n    key: \"watchForReceipt\",\n    value: function watchForReceipt(receiptId, callback) {\n      this._receiptWatchers[receiptId] = callback;\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(destination, callback) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      headers = Object.assign({}, headers);\n\n      if (!headers.id) {\n        headers.id = \"sub-\".concat(this._counter++);\n      }\n\n      headers.destination = destination;\n      this._subscriptions[headers.id] = callback;\n\n      this._transmit({\n        command: 'SUBSCRIBE',\n        headers: headers\n      });\n\n      var client = this;\n      return {\n        id: headers.id,\n        unsubscribe: function unsubscribe(hdrs) {\n          return client.unsubscribe(headers.id, hdrs);\n        }\n      };\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(id) {\n      var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      headers = Object.assign({}, headers);\n      delete this._subscriptions[id];\n      headers.id = id;\n\n      this._transmit({\n        command: 'UNSUBSCRIBE',\n        headers: headers\n      });\n    }\n  }, {\n    key: \"begin\",\n    value: function begin(transactionId) {\n      var txId = transactionId || \"tx-\".concat(this._counter++);\n\n      this._transmit({\n        command: 'BEGIN',\n        headers: {\n          transaction: txId\n        }\n      });\n\n      var client = this;\n      return {\n        id: txId,\n        commit: function commit() {\n          client.commit(txId);\n        },\n        abort: function abort() {\n          client.abort(txId);\n        }\n      };\n    }\n  }, {\n    key: \"commit\",\n    value: function commit(transactionId) {\n      this._transmit({\n        command: 'COMMIT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(transactionId) {\n      this._transmit({\n        command: 'ABORT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n  }, {\n    key: \"ack\",\n    value: function ack(messageId, subscriptionId) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      headers = Object.assign({}, headers);\n\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n\n      headers.subscription = subscriptionId;\n\n      this._transmit({\n        command: 'ACK',\n        headers: headers\n      });\n    }\n  }, {\n    key: \"nack\",\n    value: function nack(messageId, subscriptionId) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      headers = Object.assign({}, headers);\n\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n\n      headers.subscription = subscriptionId;\n      return this._transmit({\n        command: 'NACK',\n        headers: headers\n      });\n    }\n  }, {\n    key: \"connectedVersion\",\n    get: function get() {\n      return this._connectedVersion;\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this._connected;\n    }\n  }]);\n\n  return StompHandler;\n}();","map":null,"metadata":{},"sourceType":"module"}