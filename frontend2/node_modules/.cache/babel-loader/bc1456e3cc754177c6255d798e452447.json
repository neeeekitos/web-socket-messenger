{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.webstomp = factory();\n})(this, function () {\n  'use strict';\n\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n\n  var toConsumableArray = function toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  var VERSIONS = {\n    V1_0: '1.0',\n    V1_1: '1.1',\n    V1_2: '1.2',\n    // Versions of STOMP specifications supported\n    supportedVersions: function supportedVersions() {\n      return '1.2,1.1,1.0';\n    },\n    supportedProtocols: function supportedProtocols() {\n      return ['v10.stomp', 'v11.stomp', 'v12.stomp'];\n    }\n  };\n  var PROTOCOLS_VERSIONS = {\n    'v10.stomp': VERSIONS.V1_0,\n    'v11.stomp': VERSIONS.V1_1,\n    'v12.stomp': VERSIONS.V1_2\n  };\n\n  function getSupportedVersion(protocol, debug) {\n    var knownVersion = PROTOCOLS_VERSIONS[protocol];\n\n    if (!knownVersion && debug) {\n      debug('DEPRECATED: ' + protocol + ' is not a recognized STOMP version. In next major client version, this will close the connection.');\n    } // 2nd temporary fallback if the protocol\n    // does not match a supported STOMP version\n    // This fallback will be removed in next major version\n\n\n    return knownVersion || VERSIONS.V1_2;\n  } // Define constants for bytes used throughout the code.\n\n\n  var BYTES = {\n    // LINEFEED byte (octet 10)\n    LF: '\\x0A',\n    // NULL byte (octet 0)\n    NULL: '\\x00'\n  }; // utility function to trim any whitespace before and after a string\n\n  var trim = function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }; // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n\n\n  function unicodeStringToTypedArray(s) {\n    var escstr = encodeURIComponent(s);\n    var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {\n      return String.fromCharCode('0x' + p1);\n    });\n    var arr = Array.prototype.map.call(binstr, function (c) {\n      return c.charCodeAt(0);\n    });\n    return new Uint8Array(arr);\n  } // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n\n\n  function typedArrayToUnicodeString(ua) {\n    var binstr = String.fromCharCode.apply(String, toConsumableArray(ua));\n    var escstr = binstr.replace(/(.)/g, function (m, p) {\n      var code = p.charCodeAt(0).toString(16).toUpperCase();\n\n      if (code.length < 2) {\n        code = '0' + code;\n      }\n\n      return '%' + code;\n    });\n    return decodeURIComponent(escstr);\n  } // Compute the size of a UTF-8 string by counting its number of bytes\n  // (and not the number of characters composing the string)\n\n\n  function sizeOfUTF8(s) {\n    if (!s) return 0;\n    return encodeURIComponent(s).match(/%..|./g).length;\n  }\n\n  function createId() {\n    var ts = new Date().getTime();\n    var rand = Math.floor(Math.random() * 1000);\n    return ts + '-' + rand;\n  } // [STOMP Frame](http://stomp.github.com/stomp-specification-1.1.html#STOMP_Frames) Class\n\n\n  var Frame = function () {\n    // Frame constructor\n    function Frame(command) {\n      var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      classCallCheck(this, Frame);\n      this.command = command;\n      this.headers = headers;\n      this.body = body;\n    } // Provides a textual representation of the frame\n    // suitable to be sent to the server\n\n\n    createClass(Frame, [{\n      key: 'toString',\n      value: function toString() {\n        var _this = this;\n\n        var lines = [this.command],\n            skipContentLength = this.headers['content-length'] === false;\n        if (skipContentLength) delete this.headers['content-length'];\n        Object.keys(this.headers).forEach(function (name) {\n          var value = _this.headers[name];\n          lines.push(name + ':' + value);\n        });\n\n        if (this.body && !skipContentLength) {\n          lines.push('content-length:' + sizeOfUTF8(this.body));\n        }\n\n        lines.push(BYTES.LF + this.body);\n        return lines.join(BYTES.LF);\n      } // Unmarshall a single STOMP frame from a `data` string\n\n    }], [{\n      key: 'unmarshallSingle',\n      value: function unmarshallSingle(data) {\n        // search for 2 consecutives LF byte to split the command\n        // and headers from the body\n        var divider = data.search(new RegExp(BYTES.LF + BYTES.LF)),\n            headerLines = data.substring(0, divider).split(BYTES.LF),\n            command = headerLines.shift(),\n            headers = {},\n            body = '',\n            // skip the 2 LF bytes that divides the headers from the body\n        bodyIndex = divider + 2; // Parse headers in reverse order so that for repeated headers, the 1st\n        // value is used\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = headerLines.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var line = _step.value;\n            var idx = line.indexOf(':');\n            headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n          } // Parse body\n          // check for content-length or topping at the first NULL byte found.\n\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (headers['content-length']) {\n          var len = parseInt(headers['content-length'], 10);\n          body = ('' + data).substring(bodyIndex, bodyIndex + len);\n        } else {\n          var chr = null;\n\n          for (var i = bodyIndex; i < data.length; i++) {\n            chr = data.charAt(i);\n            if (chr === BYTES.NULL) break;\n            body += chr;\n          }\n        }\n\n        return new Frame(command, headers, body);\n      } // Split the data before unmarshalling every single STOMP frame.\n      // Web socket servers can send multiple frames in a single websocket message.\n      // If the message size exceeds the websocket message size, then a single\n      // frame can be fragmented across multiple messages.\n      //\n      // `datas` is a string.\n      //\n      // returns an *array* of Frame objects\n\n    }, {\n      key: 'unmarshall',\n      value: function unmarshall(datas) {\n        // split and unmarshall *multiple STOMP frames* contained in a *single WebSocket frame*.\n        // The data is split when a NULL byte (followed by zero or many LF bytes) is found\n        var frames = datas.split(new RegExp(BYTES.NULL + BYTES.LF + '*')),\n            firstFrames = frames.slice(0, -1),\n            lastFrame = frames.slice(-1)[0],\n            r = {\n          frames: firstFrames.map(function (f) {\n            return Frame.unmarshallSingle(f);\n          }),\n          partial: ''\n        }; // If this contains a final full message or just a acknowledgement of a PING\n        // without any other content, process this frame, otherwise return the\n        // contents of the buffer to the caller.\n\n        if (lastFrame === BYTES.LF || lastFrame.search(RegExp(BYTES.NULL + BYTES.LF + '*$')) !== -1) {\n          r.frames.push(Frame.unmarshallSingle(lastFrame));\n        } else {\n          r.partial = lastFrame;\n        }\n\n        return r;\n      } // Marshall a Stomp frame\n\n    }, {\n      key: 'marshall',\n      value: function marshall(command, headers, body) {\n        var frame = new Frame(command, headers, body);\n        return frame.toString() + BYTES.NULL;\n      }\n    }]);\n    return Frame;\n  }(); // STOMP Client Class\n  //\n  // All STOMP protocol is exposed as methods of this class (`connect()`,\n  // `send()`, etc.)\n\n\n  var Client = function () {\n    function Client(ws) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      classCallCheck(this, Client); // cannot have default options object + destructuring in the same time in method signature\n\n      var _options$binary = options.binary,\n          binary = _options$binary === undefined ? false : _options$binary,\n          _options$heartbeat = options.heartbeat,\n          heartbeat = _options$heartbeat === undefined ? {\n        outgoing: 10000,\n        incoming: 10000\n      } : _options$heartbeat,\n          _options$debug = options.debug,\n          debug = _options$debug === undefined ? true : _options$debug,\n          _options$protocols = options.protocols,\n          protocols = _options$protocols === undefined ? [] : _options$protocols;\n      this.ws = ws;\n      this.ws.binaryType = 'arraybuffer';\n      this.isBinary = !!binary;\n      this.hasDebug = !!debug;\n      this.connected = false; // Heartbeat properties of the client\n      // outgoing: send heartbeat every 10s by default (value is in ms)\n      // incoming: expect to receive server heartbeat at least every 10s by default\n      // falsy value means no heartbeat hence 0,0\n\n      this.heartbeat = heartbeat || {\n        outgoing: 0,\n        incoming: 0\n      }; // maximum *WebSocket* frame size sent by the client. If the STOMP frame\n      // is bigger than this value, the STOMP frame will be sent using multiple\n      // WebSocket frames (default is 16KiB)\n\n      this.maxWebSocketFrameSize = 16 * 1024; // subscription callbacks indexed by subscriber's ID\n\n      this.subscriptions = {};\n      this.partialData = '';\n      this.protocols = protocols;\n    } // //// Debugging\n    //\n    // By default, debug messages are logged in the window's console if it is defined.\n    // This method is called for every actual transmission of the STOMP frames over the\n    // WebSocket.\n    //\n    // It is possible to set a `debug(message, data)` method\n    // on a client instance to handle differently the debug messages:\n    //\n    //     client.debug = function(str) {\n    //         // append the debug log to a #debug div\n    //         $(\"#debug\").append(str + \"\\n\");\n    //     };\n\n\n    createClass(Client, [{\n      key: 'debug',\n      value: function debug() {\n        var _console;\n\n        if (this.hasDebug) (_console = console).log.apply(_console, arguments);\n      } // [CONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECT_or_STOMP_Frame)\n      //\n      // The `connect` method accepts different number of arguments and types:\n      //\n      // * `connect(headers, connectCallback)`\n      // * `connect(headers, connectCallback, errorCallback)`\n      // * `connect(login, passcode, connectCallback)`\n      // * `connect(login, passcode, connectCallback, errorCallback)`\n      // * `connect(login, passcode, connectCallback, errorCallback, host)`\n      //\n      // The errorCallback is optional and the 2 first forms allow to pass other\n      // headers in addition to `client`, `passcode` and `host`.\n\n    }, {\n      key: 'connect',\n      value: function connect() {\n        var _this = this;\n\n        var _parseConnect2 = this._parseConnect.apply(this, arguments),\n            _parseConnect3 = slicedToArray(_parseConnect2, 3),\n            headers = _parseConnect3[0],\n            connectCallback = _parseConnect3[1],\n            errorCallback = _parseConnect3[2];\n\n        this.connectCallback = connectCallback;\n        this.debug('Opening Web Socket...');\n\n        this.ws.onmessage = function (evt) {\n          var data = evt.data;\n\n          if (evt.data instanceof ArrayBuffer) {\n            data = typedArrayToUnicodeString(new Uint8Array(evt.data));\n          }\n\n          _this.serverActivity = Date.now(); // heartbeat\n\n          if (data === BYTES.LF) {\n            _this.debug('<<< PONG');\n\n            return;\n          }\n\n          _this.debug('<<< ' + data); // Handle STOMP frames received from the server\n          // The unmarshall function returns the frames parsed and any remaining\n          // data from partial frames.\n\n\n          var unmarshalledData = Frame.unmarshall(_this.partialData + data);\n          _this.partialData = unmarshalledData.partial;\n          unmarshalledData.frames.forEach(function (frame) {\n            switch (frame.command) {\n              // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECTED_Frame)\n              case 'CONNECTED':\n                _this.debug('connected to server ' + frame.headers.server);\n\n                _this.connected = true;\n                _this.version = frame.headers.version;\n\n                _this._setupHeartbeat(frame.headers);\n\n                if (connectCallback) connectCallback(frame);\n                break;\n              // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.1.html#MESSAGE)\n\n              case 'MESSAGE':\n                // the `onreceive` callback is registered when the client calls\n                // `subscribe()`.\n                // If there is registered subscription for the received message,\n                // we used the default `onreceive` method that the client can set.\n                // This is useful for subscriptions that are automatically created\n                // on the browser side (e.g. [RabbitMQ's temporary\n                // queues](http://www.rabbitmq.com/stomp.html)).\n                var subscription = frame.headers.subscription;\n                var onreceive = _this.subscriptions[subscription] || _this.onreceive;\n\n                if (onreceive) {\n                  // 1.2 define ack header if ack is set to client\n                  // and this header must be used for ack/nack\n                  var messageID = _this.version === VERSIONS.V1_2 && frame.headers.ack || frame.headers['message-id']; // add `ack()` and `nack()` methods directly to the returned frame\n                  // so that a simple call to `message.ack()` can acknowledge the message.\n\n                  frame.ack = _this.ack.bind(_this, messageID, subscription);\n                  frame.nack = _this.nack.bind(_this, messageID, subscription);\n                  onreceive(frame);\n                } else {\n                  _this.debug('Unhandled received MESSAGE: ' + frame);\n                }\n\n                break;\n              // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.1.html#RECEIPT)\n              //\n              // The client instance can set its `onreceipt` field to a function taking\n              // a frame argument that will be called when a receipt is received from\n              // the server:\n              //\n              //     client.onreceipt = function(frame) {\n              //       receiptID = frame.headers['receipt-id'];\n              //       ...\n              //     }\n\n              case 'RECEIPT':\n                if (_this.onreceipt) _this.onreceipt(frame);\n                break;\n              // [ERROR Frame](http://stomp.github.com/stomp-specification-1.1.html#ERROR)\n\n              case 'ERROR':\n                if (errorCallback) errorCallback(frame);\n                break;\n\n              default:\n                _this.debug('Unhandled frame: ' + frame);\n\n            }\n          });\n        };\n\n        this.ws.onclose = function (event) {\n          _this.debug('Whoops! Lost connection to ' + _this.ws.url + ':', {\n            event: event\n          });\n\n          _this._cleanUp();\n\n          if (errorCallback) errorCallback(event);\n        };\n\n        this.ws.onopen = function () {\n          _this.debug('Web Socket Opened...'); // 1st protocol fallback on user 1st protocols options\n          // to prevent edge case where server does not comply and respond with a choosen protocol\n          // or when ws client does not handle protocol property very well\n\n\n          headers['accept-version'] = getSupportedVersion(_this.ws.protocol || _this.protocols[0], _this.debug.bind(_this)); // Check if we already have heart-beat in headers before adding them\n\n          if (!headers['heart-beat']) {\n            headers['heart-beat'] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n          }\n\n          _this._transmit('CONNECT', headers);\n        };\n\n        if (this.ws.readyState === this.ws.OPEN) {\n          this.ws.onopen();\n        }\n      } // [DISCONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#DISCONNECT)\n\n    }, {\n      key: 'disconnect',\n      value: function disconnect(disconnectCallback) {\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        this._transmit('DISCONNECT', headers); // Discard the onclose callback to avoid calling the errorCallback when\n        // the client is properly disconnected.\n\n\n        this.ws.onclose = null;\n        this.ws.close();\n\n        this._cleanUp(); // TODO: what's the point of this callback disconnect is not async\n\n\n        if (disconnectCallback) disconnectCallback();\n      } // [SEND Frame](http://stomp.github.com/stomp-specification-1.1.html#SEND)\n      //\n      // * `destination` is MANDATORY.\n\n    }, {\n      key: 'send',\n      value: function send(destination) {\n        var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers);\n        hdrs.destination = destination;\n\n        this._transmit('SEND', hdrs, body);\n      } // [BEGIN Frame](http://stomp.github.com/stomp-specification-1.1.html#BEGIN)\n      //\n      // If no transaction ID is passed, one will be created automatically\n\n    }, {\n      key: 'begin',\n      value: function begin() {\n        var transaction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tx-' + createId();\n\n        this._transmit('BEGIN', {\n          transaction: transaction\n        });\n\n        return {\n          id: transaction,\n          commit: this.commit.bind(this, transaction),\n          abort: this.abort.bind(this, transaction)\n        };\n      } // [COMMIT Frame](http://stomp.github.com/stomp-specification-1.1.html#COMMIT)\n      //\n      // * `transaction` is MANDATORY.\n      //\n      // It is preferable to commit a transaction by calling `commit()` directly on\n      // the object returned by `client.begin()`:\n      //\n      //     var tx = client.begin(txid);\n      //     ...\n      //     tx.commit();\n\n    }, {\n      key: 'commit',\n      value: function commit(transaction) {\n        this._transmit('COMMIT', {\n          transaction: transaction\n        });\n      } // [ABORT Frame](http://stomp.github.com/stomp-specification-1.1.html#ABORT)\n      //\n      // * `transaction` is MANDATORY.\n      //\n      // It is preferable to abort a transaction by calling `abort()` directly on\n      // the object returned by `client.begin()`:\n      //\n      //     var tx = client.begin(txid);\n      //     ...\n      //     tx.abort();\n\n    }, {\n      key: 'abort',\n      value: function abort(transaction) {\n        this._transmit('ABORT', {\n          transaction: transaction\n        });\n      } // [ACK Frame](http://stomp.github.com/stomp-specification-1.1.html#ACK)\n      //\n      // * `messageID` & `subscription` are MANDATORY.\n      //\n      // It is preferable to acknowledge a message by calling `ack()` directly\n      // on the message handled by a subscription callback:\n      //\n      //     client.subscribe(destination,\n      //       function(message) {\n      //         // process the message\n      //         // acknowledge it\n      //         message.ack();\n      //       },\n      //       {'ack': 'client'}\n      //     );\n\n    }, {\n      key: 'ack',\n      value: function ack(messageID, subscription) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers); // 1.2 change id header name from message-id to id\n\n        var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n        hdrs[idAttr] = messageID;\n        hdrs.subscription = subscription;\n\n        this._transmit('ACK', hdrs);\n      } // [NACK Frame](http://stomp.github.com/stomp-specification-1.1.html#NACK)\n      //\n      // * `messageID` & `subscription` are MANDATORY.\n      //\n      // It is preferable to nack a message by calling `nack()` directly on the\n      // message handled by a subscription callback:\n      //\n      //     client.subscribe(destination,\n      //       function(message) {\n      //         // process the message\n      //         // an error occurs, nack it\n      //         message.nack();\n      //       },\n      //       {'ack': 'client'}\n      //     );\n\n    }, {\n      key: 'nack',\n      value: function nack(messageID, subscription) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers); // 1.2 change id header name from message-id to id\n\n        var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n        hdrs[idAttr] = messageID;\n        hdrs.subscription = subscription;\n\n        this._transmit('NACK', hdrs);\n      } // [SUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#SUBSCRIBE)\n\n    }, {\n      key: 'subscribe',\n      value: function subscribe(destination, callback) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers); // for convenience if the `id` header is not set, we create a new one for this client\n        // that will be returned to be able to unsubscribe this subscription\n\n        if (!hdrs.id) hdrs.id = 'sub-' + createId();\n        hdrs.destination = destination;\n        this.subscriptions[hdrs.id] = callback;\n\n        this._transmit('SUBSCRIBE', hdrs);\n\n        return {\n          id: hdrs.id,\n          unsubscribe: this.unsubscribe.bind(this, hdrs.id)\n        };\n      } // [UNSUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#UNSUBSCRIBE)\n      //\n      // * `id` is MANDATORY.\n      //\n      // It is preferable to unsubscribe from a subscription by calling\n      // `unsubscribe()` directly on the object returned by `client.subscribe()`:\n      //\n      //     var subscription = client.subscribe(destination, onmessage);\n      //     ...\n      //     subscription.unsubscribe(headers);\n\n    }, {\n      key: 'unsubscribe',\n      value: function unsubscribe(id) {\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var hdrs = Object.assign({}, headers);\n        delete this.subscriptions[id];\n        hdrs.id = id;\n\n        this._transmit('UNSUBSCRIBE', hdrs);\n      } // Clean up client resources when it is disconnected or the server did not\n      // send heart beats in a timely fashion\n\n    }, {\n      key: '_cleanUp',\n      value: function _cleanUp() {\n        this.connected = false;\n        clearInterval(this.pinger);\n        clearInterval(this.ponger);\n      } // Base method to transmit any stomp frame\n\n    }, {\n      key: '_transmit',\n      value: function _transmit(command, headers, body) {\n        var out = Frame.marshall(command, headers, body);\n        this.debug('>>> ' + out, {\n          frame: {\n            command: command,\n            headers: headers,\n            body: body\n          }\n        });\n\n        this._wsSend(out);\n      }\n    }, {\n      key: '_wsSend',\n      value: function _wsSend(data) {\n        if (this.isBinary) data = unicodeStringToTypedArray(data);\n        this.debug('>>> length ' + data.length); // if necessary, split the *STOMP* frame to send it on many smaller\n        // *WebSocket* frames\n\n        while (true) {\n          if (data.length > this.maxWebSocketFrameSize) {\n            this.ws.send(data.slice(0, this.maxWebSocketFrameSize));\n            data = data.slice(this.maxWebSocketFrameSize);\n            this.debug('remaining = ' + data.length);\n          } else {\n            return this.ws.send(data);\n          }\n        }\n      } // Heart-beat negotiation\n\n    }, {\n      key: '_setupHeartbeat',\n      value: function _setupHeartbeat(headers) {\n        var _this2 = this;\n\n        if (this.version !== VERSIONS.V1_1 && this.version !== VERSIONS.V1_2) return; // heart-beat header received from the server looks like:\n        //\n        //     heart-beat: sx, sy\n\n        var _split$map = (headers['heart-beat'] || '0,0').split(',').map(function (v) {\n          return parseInt(v, 10);\n        }),\n            _split$map2 = slicedToArray(_split$map, 2),\n            serverOutgoing = _split$map2[0],\n            serverIncoming = _split$map2[1];\n\n        if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n          var ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n          this.debug('send PING every ' + ttl + 'ms');\n          this.pinger = setInterval(function () {\n            _this2._wsSend(BYTES.LF);\n\n            _this2.debug('>>> PING');\n          }, ttl);\n        }\n\n        if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n          var _ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n\n          this.debug('check PONG every ' + _ttl + 'ms');\n          this.ponger = setInterval(function () {\n            var delta = Date.now() - _this2.serverActivity; // We wait twice the TTL to be flexible on window's setInterval calls\n\n\n            if (delta > _ttl * 2) {\n              _this2.debug('did not receive server activity for the last ' + delta + 'ms');\n\n              _this2.ws.close();\n            }\n          }, _ttl);\n        }\n      } // parse the arguments number and type to find the headers, connectCallback and\n      // (eventually undefined) errorCallback\n\n    }, {\n      key: '_parseConnect',\n      value: function _parseConnect() {\n        var headers = {},\n            connectCallback = void 0,\n            errorCallback = void 0;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        switch (args.length) {\n          case 2:\n            headers = args[0];\n            connectCallback = args[1];\n            break;\n\n          case 3:\n            if (args[1] instanceof Function) {\n              headers = args[0];\n              connectCallback = args[1];\n              errorCallback = args[2];\n            } else {\n              headers.login = args[0];\n              headers.passcode = args[1];\n              connectCallback = args[2];\n            }\n\n            break;\n\n          case 4:\n            headers.login = args[0];\n            headers.passcode = args[1];\n            connectCallback = args[2];\n            errorCallback = args[3];\n            break;\n\n          default:\n            headers.login = args[0];\n            headers.passcode = args[1];\n            connectCallback = args[2];\n            errorCallback = args[3];\n            headers.host = args[4];\n        }\n\n        return [headers, connectCallback, errorCallback];\n      }\n    }]);\n    return Client;\n  }(); // The `webstomp` Object\n\n\n  var webstomp = {\n    Frame: Frame,\n    VERSIONS: VERSIONS,\n    // This method creates a WebSocket client that is connected to\n    // the STOMP server located at the url.\n    client: function client(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ws = new WebSocket(url, options.protocols || VERSIONS.supportedProtocols());\n      return new Client(ws, options);\n    },\n    // This method is an alternative to `webstomp.client()` to let the user\n    // specify the WebSocket to use (either a standard HTML5 WebSocket or\n    // a similar object).\n    over: function over() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return new (Function.prototype.bind.apply(Client, [null].concat(args)))();\n    }\n  };\n  return webstomp;\n});","map":null,"metadata":{},"sourceType":"script"}